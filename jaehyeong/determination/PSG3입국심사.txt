class Solution {
    public long solution(int n, int[] times) {
        
        int min = Integer.MAX_VALUE;
        int max = 0;
        for(int i : times) {
            min = Math.min(min, i);
            max = Math.max(max, i);
        }
        
        long answer = 0;

        
        long L = min; // 최저 타임 계산 해야하나?
        long R = (long) max * n;

        while(L <= R) {
            long mid = (L+R) / 2;

            if(determine(mid, times, n)) {
                R = mid - 1;
                answer = mid;
            } else {
                L = mid + 1;
            }
        }
        return answer;
    }
    
    boolean determine(long mid, int[] times, int n) {
        long sum = 0;
        for(int i : times) sum += mid / i;
        
        return sum >= n;
    }
}

/*
 - n명의 사람이, 심사원들에게 심사를 받는다.
 - 심사 시간이 최소가 되도록 하자.
 
 - 사람은  10억명 이하 1명 이상
 - 심사시간은 10억분 이상 1분 이하
 - 심사관은 10만명 이하 1명 이상
 
1. 정답의 최대치
    심사시간 10억분, 10억명일 때 ...  long 값 사용
2. 간단한 접근
    순서대로 사람을 배정한다.
    각 심사관이 심사하는데 걸리는 시간은 심사시간*사람 수 이다.
    결국 걸리는 시간은 모든 심사관 중 가장 소요시간이 긴 시간을 의미한다.
    
    모든 경우의 수로 각 심사관들에게 사람들을 배정 해본다. (시간 초과)
3. 개선된 접근
    즉, 문제는 각 심사관에게 사람들을 배정 했을 때, 소요시간의 최소는?
    최솟 값을 구하는 문제이다. 이분 탐색을 적용해보자.
    소요시간이 X이상이 되도록, n명의 사람으로 심사관에게 배정할 수 있는가?
    소요시간
    
    배정은 어떻게 하는가?
    10억명의 사람을 10만개로 나누어 배정 한다? 조합은 시간 초과...
    다른 방법은?
    X라는 소요시간 내에 심사관들이 각각 몇 명의 사람을 배정받을 수 있는가를 보자.
    100이라는 시간이면 10분 걸리는 심사관은 10명으 배정, 70분 걸리는 심사관은 1명이 가능하다.
    100 / 10 = 10 ... 100 / 70 = 1
    따라서 총 11명 까지 사람을 배정할 수 있다.
    
    X라는 소요시간이 줄어들 수록 배정할 수 있는 사람 수가 줄어든다.
    결국 NONONO YESYESYES 꼴이 되어서 특정 지점까지만 N명의 사람에게 배정할 수 있게 되어 최솟값을 구할 수 있다.
4. 시간 복잡도
    이분 탐색에 log10억, 배정 결과 탐색에 10만 = 10만 * 30 ... 충분
5. 설계
    이분 탐색으로 심사시간을 탐색한다.
        mid 값(심사시간)으로 N명의 사람을 배정할 수 있으면, 심사시간을 줄인다. R + 1
        배정할 수 없으면 심사시간을 늘린다. L = mid + 1
        N명에게 배정할 수 잇는 심사시간 최솟 값을 반환 한다.
6. 케이스
    times가 모두 1 인 경우
    times가 1개인 경우
    사람 수가 1명인 경우
    심사 시간이 큰 경우
    
    

*/